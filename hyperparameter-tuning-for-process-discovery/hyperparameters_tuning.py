# A set of Transfer Bayesian optimization algorithms with non-expensive constraint handling ability #
# The implementations assume function maximization by default. For minimization, please multiply objective by -1 #
# The implementations assume that all decision variables are box-constrained in [0,1] #
import scipy as sp
import numpy as np
#  from numpy.linalg import inv
import pandas as pd
import os
import sys
import time
import re
import random
from datetime import datetime 
import pickle

from tbo import cboa
from tbo import mpsboa
from tbo import msgtboa

import pm4py
from pm4py.objects.conversion.log import converter as log_converter
# miner
from pm4py.algo.discovery.inductive import algorithm as inductive_miner
from pm4py.algo.discovery.heuristics import algorithm as heuristics_miner
# performance metrics
from pm4py.algo.evaluation.replay_fitness import algorithm as replay_fitness_evaluator
from pm4py.algo.evaluation.precision import algorithm as precision_evaluator
from pm4py.algo.evaluation.generalization import algorithm as generalization_evaluator
from pm4py.algo.evaluation.simplicity import algorithm as simplicity_evaluator

#  from plotnine import *
#  from mizani.breaks import date_breaks
#  from mizani.formatters import date_format

import argparse
parser = argparse.ArgumentParser(description="Tune the hyperparameters of process discovery methods with Abhishek's package.")
parser.add_argument('--miner', dest='miner', type=str, help='a process discovery miner to be used')
parser.add_argument('--method', dest='method', type=str, help='a method to be tested')
parser.add_argument('--round', dest='round', type=int, help='the number of iterations')
parser.add_argument('--event-log-path', dest='event_log_path', type=str, help='an event log to be used')
parser.add_argument('--n-samples', dest='n_samples', default=25, type=int, help='the number of samples to be generated by an optimizer (default: 25)')
args = parser.parse_args()

################# Testing code #########################################
# Get input data and convert to input data #change file path
miner = args.miner
method = args.method
n_samples = args.n_samples
#  read a dataset
event_log = pm4py.read_xes(args.event_log_path)

if miner == 'inductive_miner':
    dim = 1
elif miner == 'heuristics_miner':
    dim = 6
    # TODO: need to look into the parameters' range
    LOOP_LENGTH_TWO_THRESH = [1, 5]
    MIN_ACT_COUNT = [1, 5]
    MIN_DFG_OCCURRENCES = [1, 5]
    LOOP_LENGTH_TWO_THRESH = [1, 5]

# scale_range: scale and shift a value given by Abhishek's library to actual parameter range
def scale_range(x, param_range, is_integer=True):
    if is_integer:
        return round(x * (max(param_range) - min(param_range)) + min(param_range))
    else:
        return x * (max(param_range) - min(param_range)) + min(param_range)

# f(x): input into boa, mspboa, ...
def f(x):
    if miner == 'inductive_miner':
        net, im, fm = inductive_miner.apply(event_log, 
            {pm4py.algo.discovery.inductive.variants.im.algorithm.Parameters.NOISE_THRESHOLD: x[0]},
            pm4py.algo.discovery.inductive.algorithm.Variants.IMf)
    elif miner == 'heuristics_miner':
        net, im, fm = heuristics_miner.apply(event_log, {
            heuristics_miner.Variants.CLASSIC.value.Parameters.DEPENDENCY_THRESH: x[0],
            heuristics_miner.Variants.CLASSIC.value.Parameters.AND_MEASURE_THRESH: x[1],
            heuristics_miner.Variants.CLASSIC.value.Parameters.MIN_ACT_COUNT: scale_range(x[2], MIN_ACT_COUNT, is_integer=True),
            heuristics_miner.Variants.CLASSIC.value.Parameters.MIN_DFG_OCCURRENCES: scale_range(x[3], MIN_DFG_OCCURRENCES, is_integer=True),
            heuristics_miner.Variants.CLASSIC.value.Parameters.DFG_PRE_CLEANING_NOISE_THRESH: x[4],
            heuristics_miner.Variants.CLASSIC.value.Parameters.LOOP_LENGTH_TWO_THRESH: scale_range(x[5], LOOP_LENGTH_TWO_THRESH, is_integer=True)})

    # A paper "Quality dimensions in process discovery: The importance of fitness, precision, generalization and simplicity" proposed to calculate the following four metrics, and suggest giving 10 times more weight to replay fitness than the other three.
    # 10 x + 3x = 1 => x = 1 / 13
    weights = [10/13, 1/13, 1/13, 1/13]
    fitness = replay_fitness_evaluator.apply(event_log, net, im, fm, 
            variant=replay_fitness_evaluator.Variants.TOKEN_BASED)['log_fitness']
    precision = precision_evaluator.apply(event_log, net, im, fm, 
            variant=precision_evaluator.Variants.ETCONFORMANCE_TOKEN)
    #  fitness = replay_fitness_evaluator.apply(event_log, net, im, fm, 
            #  variant=replay_fitness_evaluator.Variants.ALIGNMENT_BASED)['log_fitness']
    #  precision = precision_evaluator.apply(event_log, net, im, fm, 
            #  variant=precision_evaluator.Variants.ALIGN_ETCONFORMANCE)
    generalization = generalization_evaluator.apply(event_log, net, im, fm)
    simplicity = simplicity_evaluator.apply(net)
    score = np.dot(weights, [fitness, precision, generalization, simplicity])
    return score

# only mspboa and msgtboa require cboa results
if not method == 'cboa':
    cboa_results_dir = './results/'
    r = re.compile('.*_cboa_output.pickle')
    cboa_outputs = list(filter(r.match, os.listdir(cboa_results_dir)))

for i in range(args.round):
    current_datetime = datetime.now().strftime('%Y-%m-%d %H:%M:%S')
    print(current_datetime, '\n--- Round {} ---'.format(i+1))
    # measure computation time
    start_time = time.time()
    if method == 'cboa':
        result = cboa(f, dim, n_samples, init_sample_size=5, f_con=None)
    elif method == 'mpsboa':
        # randomly pick a cboa result
        chosen_result = random.sample(cboa_outputs, 1)[0]
        _, _, xS, yS = pickle.load(open(cboa_results_dir + chosen_result, 'rb'))
        result = mpsboa(f, dim, n_samples, xS, yS, init_sample_size=5, f_con=None)
    elif method == 'msgtboa':
        # randomly pick two cboa results
        chosen_results = random.sample(cboa_outputs, 2)
        _, _, xS1, yS1 = pickle.load(open(cboa_results_dir + chosen_results[0], 'rb'))
        _, _, xS2, yS2 = pickle.load(open(cboa_results_dir + chosen_results[1], 'rb'))
        xS = [xS1, xS2]
        yS = [yS1, yS2]
        result = msgtboa(f, dim, n_samples, xS, yS, init_sample_size=5, f_con=None)
    elapsed_time = round(time.time() - start_time)
    print('Result:', result)
    print('Elapsed time: {:,.1f}s'.format(elapsed_time))
    # save a result
    prefix = './results/' + current_datetime + '_' + miner + '_' + method
    pickle.dump(elapsed_time, file=open(prefix + '_elapsed_time.pickle', 'wb'))
    pickle.dump(result, open(prefix + '_output.pickle', 'wb'))
